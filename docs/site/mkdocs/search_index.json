{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to TQ1 - iOS SDK docs\n\n\nTQ1 is a tool for sending remote notifications using the power of geolocation to find your loyal costumers on the right spot and send them the right message.\n\n\nThis guide aims to help you to integrate your existent applications with our services. Before starting, be sure that you have all the required constants for the integration. A tutorial on how to get them can be found under the \nRequirements\n section.\n\n\nHere\n you can check our iOS API reference.\nFor full documentation check the menu on the left.", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-tq1-ios-sdk-docs", 
            "text": "TQ1 is a tool for sending remote notifications using the power of geolocation to find your loyal costumers on the right spot and send them the right message.  This guide aims to help you to integrate your existent applications with our services. Before starting, be sure that you have all the required constants for the integration. A tutorial on how to get them can be found under the  Requirements  section.  Here  you can check our iOS API reference.\nFor full documentation check the menu on the left.", 
            "title": "Welcome to TQ1 - iOS SDK docs"
        }, 
        {
            "location": "/0-requirements/", 
            "text": "TQ1 Requirements\n\n\nThis file describes the requirements for any iOS project to be considered ready for the TQ1 services.\n\n\nTL;DR\n\n\nFor development iOS applications you must have:\n\n\n\n\nYour application registered at \niOS Developer Portal\n.\n\n\nPush Notifications\n services enabled.\n\n\nAn Apple Push Notification service SSL (Sandbox) certificate exported as a \n.p12 file\n.\n\n\nThe \npassword\n for the above specified certificate.\n\n\n\n\nFor staging or production iOS applications you must have:\n\n\n\n\nYour application registered at \niOS Developer Portal\n.\n\n\nPush Notifications\n services enabled.\n\n\nAn Apple Push Notification service SSL (Production) certificate exported as a \n.p12 file\n.\n\n\nThe \npassword\n for the above specified certificate.\n\n\n\n\niOS\n\n\nThis guide assumes that:\n\n\n\n\nYou have an Apple Account and you are registered in an iOS Developers Program. Otherwise you can follow \nthese instructions\n.\n\n\n\n\nDevelopment\n\n\nThen keep going with the following items\n\n\n\n\nAccess your \niOS Developer Portal\n.\n\n\n\n\nFind the identifiers section.\n\n\n\n3. In the case you haven't registered your App ID yet, click on the '+' symbol and follow the instructions presented there. Do not forget to enable \nPush Notifications\n.\n\n\n\n\n4. Create a Push Certificate.\n  1. Select your application on the App IDs list and, then, click on the edit button. You will see all the services available for your application. In \nPush Notifications\n section, create a development certificate.\n\n\n\n\n  2. Follow the presented instructions and download the certificate as an \naps_development.cert\n file.\n  3. Double-click the certificate and add it to your \nKeychain\n.\n\n\n\n\n\n\nExport the certificate.\n\n\n\n\nWith the Keychain Access application open, click on the certificate and select the option \nExport \"Apple Development IOS Push Services...\"\n.\n\n\n\n\nSelect the option \nPersonal Information Exchange (.p12)\n.\n\n\n\n  3. A dialog will appear asking you to provide a \npassword\n for the key.\n\n  4. Then store securely your \ncertificate.p12\n file.\n\n\n\n\n\n\nBoth the \ncertificate.p12\n and \npassword\n are required for the TQ1 setup.\n\n\n\n\n\n\nStaging and Production\n\n\n\n\nFor the staging environment setup, use the same application created for development, whereas for production you should create a new one following the previous steps [1-5]\n\n\nThe only difference is that you should create an Apple Push Notification service SSL (Production) certificate instead of a Sandbox one.\n    \n\n\nBoth the \ncertificate.p12\n and \npassword\n are required for the TQ1 setup.", 
            "title": "1 Requirements"
        }, 
        {
            "location": "/0-requirements/#tq1-requirements", 
            "text": "This file describes the requirements for any iOS project to be considered ready for the TQ1 services.", 
            "title": "TQ1 Requirements"
        }, 
        {
            "location": "/0-requirements/#tldr", 
            "text": "For development iOS applications you must have:   Your application registered at  iOS Developer Portal .  Push Notifications  services enabled.  An Apple Push Notification service SSL (Sandbox) certificate exported as a  .p12 file .  The  password  for the above specified certificate.   For staging or production iOS applications you must have:   Your application registered at  iOS Developer Portal .  Push Notifications  services enabled.  An Apple Push Notification service SSL (Production) certificate exported as a  .p12 file .  The  password  for the above specified certificate.", 
            "title": "TL;DR"
        }, 
        {
            "location": "/0-requirements/#ios", 
            "text": "This guide assumes that:   You have an Apple Account and you are registered in an iOS Developers Program. Otherwise you can follow  these instructions .   Development  Then keep going with the following items   Access your  iOS Developer Portal .   Find the identifiers section.  \n3. In the case you haven't registered your App ID yet, click on the '+' symbol and follow the instructions presented there. Do not forget to enable  Push Notifications .  \n4. Create a Push Certificate.\n  1. Select your application on the App IDs list and, then, click on the edit button. You will see all the services available for your application. In  Push Notifications  section, create a development certificate.  \n  2. Follow the presented instructions and download the certificate as an  aps_development.cert  file.\n  3. Double-click the certificate and add it to your  Keychain .    Export the certificate.   With the Keychain Access application open, click on the certificate and select the option  Export \"Apple Development IOS Push Services...\" .   Select the option  Personal Information Exchange (.p12) .  \n  3. A dialog will appear asking you to provide a  password  for the key. \n  4. Then store securely your  certificate.p12  file.    Both the  certificate.p12  and  password  are required for the TQ1 setup.    Staging and Production   For the staging environment setup, use the same application created for development, whereas for production you should create a new one following the previous steps [1-5]  The only difference is that you should create an Apple Push Notification service SSL (Production) certificate instead of a Sandbox one.\n      Both the  certificate.p12  and  password  are required for the TQ1 setup.", 
            "title": "iOS"
        }, 
        {
            "location": "/1-setup/", 
            "text": "TQ1 Setup\n\n\nAdding Podfile\n\n\nIn order to use TQ1 SDK, you must add the lib by editing your Podfile.\n\n\ntarget :yourTarget do\n  pod 'TQ1SDK', :git =\n 'https://github.com/tq1/taqtile-sdk-ios.git', :tag =\n '3.0.13-no-tracking'\nend\n\n\n\n\nAfter a \npod install\n, the SDK will be ready to use.\n\n\nGetting your app key\n\n\nTo use TQ1, you will need an app key, that will identify your application on our server. In order to get this app key, you can login to our admin and:\n\n\n\n\nGo to the \nAdministration\n section;\n\n\nGo to the apps menu;\n\n\nClick on the edit button for the desired app;\n\n\nYou will see the information on the \nKey\n field.\n\n\n\n\n\n\n\n\nEnabling remote notifications\n\n\nBefore being able to register for remote notifications and for TQ1 to work correctly, you need to enable it on your app configurations:\n\n\n\n\nOn the app configurations, go to capabilities\n\n\nEnable background modes\n\n\nCheck \nLocation updates\n, \nBackground fetch\n and \nRemote notifications\n\n\n\n\n\n\nAdding TQ1 domain to http exception\n\n\nCurrent version of TQ1 uses http to communicate with the server, so, after iOS 9 you need to add an exception in order to complete the requests. Check [here] (https://ste.vn/2015/06/10/configuring-app-transport-security-ios-9-osx-10-11/) for more detailed instructions. The exception added must have the following format:\n\n\nkey\nNSAppTransportSecurity\n/key\n\n    \ndict\n\n        \nkey\nNSExceptionDomains\n/key\n\n        \ndict\n\n            \nkey\napi.analytics.tq1.taqtile.io\n/key\n\n            \ndict\n\n                \nkey\nNSIncludesSubdomains\n/key\n\n                \ntrue/\n\n                \nkey\nNSTemporaryExceptionAllowsInsecureHTTPLoads\n/key\n\n                \ntrue/\n\n            \n/dict\n\n        \n/dict\n\n    \n/dict", 
            "title": "2 Setup"
        }, 
        {
            "location": "/1-setup/#tq1-setup", 
            "text": "", 
            "title": "TQ1 Setup"
        }, 
        {
            "location": "/1-setup/#adding-podfile", 
            "text": "In order to use TQ1 SDK, you must add the lib by editing your Podfile.  target :yourTarget do\n  pod 'TQ1SDK', :git =  'https://github.com/tq1/taqtile-sdk-ios.git', :tag =  '3.0.13-no-tracking'\nend  After a  pod install , the SDK will be ready to use.", 
            "title": "Adding Podfile"
        }, 
        {
            "location": "/1-setup/#getting-your-app-key", 
            "text": "To use TQ1, you will need an app key, that will identify your application on our server. In order to get this app key, you can login to our admin and:   Go to the  Administration  section;  Go to the apps menu;  Click on the edit button for the desired app;  You will see the information on the  Key  field.", 
            "title": "Getting your app key"
        }, 
        {
            "location": "/1-setup/#enabling-remote-notifications", 
            "text": "Before being able to register for remote notifications and for TQ1 to work correctly, you need to enable it on your app configurations:   On the app configurations, go to capabilities  Enable background modes  Check  Location updates ,  Background fetch  and  Remote notifications", 
            "title": "Enabling remote notifications"
        }, 
        {
            "location": "/1-setup/#adding-tq1-domain-to-http-exception", 
            "text": "Current version of TQ1 uses http to communicate with the server, so, after iOS 9 you need to add an exception in order to complete the requests. Check [here] (https://ste.vn/2015/06/10/configuring-app-transport-security-ios-9-osx-10-11/) for more detailed instructions. The exception added must have the following format:  key NSAppTransportSecurity /key \n     dict \n         key NSExceptionDomains /key \n         dict \n             key api.analytics.tq1.taqtile.io /key \n             dict \n                 key NSIncludesSubdomains /key \n                 true/ \n                 key NSTemporaryExceptionAllowsInsecureHTTPLoads /key \n                 true/ \n             /dict \n         /dict \n     /dict", 
            "title": "Adding TQ1 domain to http exception"
        }, 
        {
            "location": "/2-start/", 
            "text": "Start TQ1\n\n\nPreparing the AppDelegate\n\n\nThe first thing to do is to make your \nAppDelegate\n implement the \nTQDelegate\n interface, so it will be able to handle push notifications.\n\n\nTo make possible for the user to receive pushes, first it's necessary to make some configuration. To do it, set the TQ's required configurations, like in the following example:\n\n\n@interface AppDelegate : UIResponder \nUIApplicationDelegate, TQ1Delegate\n\n\n\n\n\nOnce you add the \nTQDelegate\nan error will appear, that is because you have to implement the following \nTQDelegate\n  methods:\n\n\n-(void)handleBackgroundPushNotification:(NSDictionary *)userInfo pushId:(NSString *)pushId\n{\n}\n\n-(void)handleForegroundPushNotification:(NSDictionary *)userInfo pushId:(NSString *)pushId\n{\n}\n\n-(void)handleCustomActionWithIdentifier:(NSString *)identifier pushId:(NSString *)pushId\n{\n}\n\n\n\n\nThey will be explained later on the \npush notifications section\n.\n\n\nStart method\n\n\n[[TQ1 shared] startWithKey:AppKey];\n[[TQ1 shared] trackRemoteNofitications:self];\n\n\n\n\n\n\nAppKey: the app identifier that will be used by our server. In order to get it, check the setup section.\n\n\n\n\nThe first method will send the device information to our server and the second one will inform \nTQ1 SDK\n that this class will handle the push notifications. Note that, ideally \ntrackRemoteNofitications\n should be run at the start of \ndidFinishLaunching\n application method so the sdk can receive the necessary messages.\n\n\nRegister for remote notifications\n\n\nIn order to receive notifications, you will have to register your application. In order to do this you can follow the \niOS documentation\n, or simply do like the example below:\n\n\n//Inside didFinishLaunching\n[[UIApplication sharedApplication] registerUserNotificationSettings:[UIUserNotificationSettings settingsForTypes:(UIUserNotificationTypeSound | UIUserNotificationTypeAlert | UIUserNotificationTypeBadge) categories:nil]];\n\n\n\n\nWith this configuration, the app may:\n  - badge its icon upon a notification being received\n  - play a sound upon a notification being received\n  - display an alert upon a notification being received\n\n\nYou need also to implement:\n\n\n- (void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)notificationSettings\n{\n    [[NSNotificationCenter defaultCenter]\n     postNotificationName:@\nnotification.alert.registered\n\n     object:notificationSettings];\n    [[UIApplication sharedApplication] registerForRemoteNotifications];\n}\n\n\n\n\nOnce this is done, when you run the app TQ1 will automatically detect that you've registered for remote notifications and will send the device token to the server (you can check the logs, there should be a request to TQ1 with the words \ndevice-token\n).", 
            "title": "3 Start"
        }, 
        {
            "location": "/2-start/#start-tq1", 
            "text": "", 
            "title": "Start TQ1"
        }, 
        {
            "location": "/2-start/#preparing-the-appdelegate", 
            "text": "The first thing to do is to make your  AppDelegate  implement the  TQDelegate  interface, so it will be able to handle push notifications.  To make possible for the user to receive pushes, first it's necessary to make some configuration. To do it, set the TQ's required configurations, like in the following example:  @interface AppDelegate : UIResponder  UIApplicationDelegate, TQ1Delegate   Once you add the  TQDelegate an error will appear, that is because you have to implement the following  TQDelegate   methods:  -(void)handleBackgroundPushNotification:(NSDictionary *)userInfo pushId:(NSString *)pushId\n{\n}\n\n-(void)handleForegroundPushNotification:(NSDictionary *)userInfo pushId:(NSString *)pushId\n{\n}\n\n-(void)handleCustomActionWithIdentifier:(NSString *)identifier pushId:(NSString *)pushId\n{\n}  They will be explained later on the  push notifications section .", 
            "title": "Preparing the AppDelegate"
        }, 
        {
            "location": "/2-start/#start-method", 
            "text": "[[TQ1 shared] startWithKey:AppKey];\n[[TQ1 shared] trackRemoteNofitications:self];   AppKey: the app identifier that will be used by our server. In order to get it, check the setup section.   The first method will send the device information to our server and the second one will inform  TQ1 SDK  that this class will handle the push notifications. Note that, ideally  trackRemoteNofitications  should be run at the start of  didFinishLaunching  application method so the sdk can receive the necessary messages.", 
            "title": "Start method"
        }, 
        {
            "location": "/2-start/#register-for-remote-notifications", 
            "text": "In order to receive notifications, you will have to register your application. In order to do this you can follow the  iOS documentation , or simply do like the example below:  //Inside didFinishLaunching\n[[UIApplication sharedApplication] registerUserNotificationSettings:[UIUserNotificationSettings settingsForTypes:(UIUserNotificationTypeSound | UIUserNotificationTypeAlert | UIUserNotificationTypeBadge) categories:nil]];  With this configuration, the app may:\n  - badge its icon upon a notification being received\n  - play a sound upon a notification being received\n  - display an alert upon a notification being received  You need also to implement:  - (void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)notificationSettings\n{\n    [[NSNotificationCenter defaultCenter]\n     postNotificationName:@ notification.alert.registered \n     object:notificationSettings];\n    [[UIApplication sharedApplication] registerForRemoteNotifications];\n}  Once this is done, when you run the app TQ1 will automatically detect that you've registered for remote notifications and will send the device token to the server (you can check the logs, there should be a request to TQ1 with the words  device-token ).", 
            "title": "Register for remote notifications"
        }, 
        {
            "location": "/3-analytics/", 
            "text": "Custom Data\n\n\nYou can send user specific information using \nCustom Data\n main access method, these information will be used to filter users when sending push notifications:\n\n\n  - (void)addCustomData:(NSDictionary *)customData completion:(void (^)(BOOL success))completion;\n\n\n\n\nThe argument \ncustomData\n must be a dictionary with NSString values.\nAnother method is available to send custom data:\n\n\n  - (void)addCustomData:(NSDictionary *)customData keysToIgnore:(NSArray *)keysToIgnore completion:(void (^)(BOOL success))completion;\n\n\n\n\nThe argument \nkeysToIgnore\n is an array of keys from \ncustomData\n that optionally can be passed. These keys will be ignored while filtering audience in TQ1 admin portal.\n\n\nOnce you send it you can check the push notification sending page, as they will appear under the \nCustom Filter\n section:", 
            "title": "4 Analytics"
        }, 
        {
            "location": "/3-analytics/#custom-data", 
            "text": "You can send user specific information using  Custom Data  main access method, these information will be used to filter users when sending push notifications:    - (void)addCustomData:(NSDictionary *)customData completion:(void (^)(BOOL success))completion;  The argument  customData  must be a dictionary with NSString values.\nAnother method is available to send custom data:    - (void)addCustomData:(NSDictionary *)customData keysToIgnore:(NSArray *)keysToIgnore completion:(void (^)(BOOL success))completion;  The argument  keysToIgnore  is an array of keys from  customData  that optionally can be passed. These keys will be ignored while filtering audience in TQ1 admin portal.  Once you send it you can check the push notification sending page, as they will appear under the  Custom Filter  section:", 
            "title": "Custom Data"
        }, 
        {
            "location": "/4-notifications/", 
            "text": "Handling incoming pushes\n\n\nBasically there are two classes that handle push notifications: TQ1Inbox and TQ1InboxMessage, both described in 'TQ1Inbox.h'.\n\n\nJust note that, since there should only exist one TQ1Inbox per app, the correct way to call those methods is by sending the message to the 'shared' return. The 'shared' method will take care of creating an inbox or returning the existing one.\n\n\n//For example:\n[[TQ1Inbox shared] getInboxMessage: @\n1234\n]\n\n\n\n\nAlso, one should create a class that handles how the app behaves when a push is received by implementing the TQDelegate protocol, defined in TQ1.h:\n\n\n@protocol TQDelegate \nNSObject\n\n  //method used to handle foreground push notifications\n  - (void)handleForegroundPushNotification:(NSDictionary *)userInfo pushId:(NSString *) pushId;\n\n  //method used to handle background push notifications\n  - (void)handleBackgroundPushNotification:(NSDictionary *)userInfo pushId:(NSString *) pushId;\n\n  //method to handle push notification custom actions\n  -(void)handleCustomActionWithIdentifier:(NSString *)identifier pushId:(NSString *)pushId\n@end\n\n\n\n\nWhen the push first arrives, the app may or may not be open, in background, etc; so it's necessary to implement the protocol \nTQDelegate\n and the \ndidFinishLaunchingWithOptions\n event that will determinate the actions to take in each state.\nIn special, the TQProtocol will describe what happens when the app is open, and in its' implementation it will become necessary to get the received push (to display it, for example). In that case one should use the method \ngetInboxMessage\n inside the protocol's implementation, since they do receive the received push's id:\n\n\n- (void)handleBackgroundPushNotification:(NSDictionary *)userInfo pushId:(NSString *) pushId\n{\n    TQ1InboxMessage *receivedPush;\n    //Code\n    receivedPush = [[[TQ1Inbox] shared] getInboxMessage: pushId];\n    //More code\n}\n\n\n\n\nGetting the push notification custom content\n\n\nWhen you send a custom content along with a push notification, you must first request this content to our server before using it. In order to do this you can use the \nretrieveCustomContent\n method, like in the following example:\n\n\n-(void)handleBackgroundPushNotification:(NSDictionary *)userInfo pushId:(NSString *)pushId\n{\n    TQ1InboxMessage *message = [[TQ1Inbox shared] getInboxMessage:pushId];\n    if(!notification.complete)\n    {\n        [[TQ1Inbox shared] retrieveCustomContent:notification.id completion:^(BOOL success, TQ1InboxMessage *notification)\n        {\n            //handle notification content\n        }];\n    }\n    else\n    {\n        //handle notification content\n    }\n}\n\n\n\n\nYou can find more details about this method below.\n\n\nHandling the notification content\n\n\nThere are three types of notification content:\n\n\n\n\nHTML - An HTML to be rendered by the app\n\n\nLink - An URL, usually for showing a page in a web view\n\n\nTag - Key/value pair, usually for redirecting to pages inside the application\n\n\n\n\nNote that the app is responsible for treating the content, so the possiblities are infinite. Here is an example on how to handle these contents:\n\n\n// This is for the notifications whose types are custom content (html) and external link (link)\nif(notification.type == TQ1InboxMessageTypeHtml || notification.type == TQ1InboxMessageTypeLink)\n{\n    ContentViewController *ctrl = [[ContentViewController alloc] init];\n    ctrl.notification = notification;\n    ctrl.notification = [[TQ1Inbox shared] getInboxMessage:notification.id];\n    [navController pushViewController:ctrl animated:YES];\n}\n\n// This is for notifications whose type is app redirection (tag) - Goes to the view tag indicates\nelse if(notification.type == TQ1InboxMessageTypeTag)\n{\n    if([notification.content objectForKey:@\nSearch\n])\n    {\n        SearchViewController *searchCtrl = [[SearchViewController alloc] init];\n        [navController pushViewController:searchCtrl animated:YES];\n    }\n    if(notification.status == TQ1InboxMessageStatusUnread)\n        [[TQ1Inbox shared] markAsRead:notification.id];\n}\n\n\n\n\nHandling all received pushes\n\n\nNow, when there are already received pushes in the inbox and it's necessary to show those, the natural thing to do should be to get all read/unread pushes, and to do that call \ngetInboxMessages\n on the inbox. That method takes a status to do the filtering. The possible status are defined in an enum in the header, but here they are:\n\n\ntypedef enum\n{\n  TQ1InboxMessageStatusUnread,\n  TQ1InboxMessageStatusRead,\n  TQ1InboxMessageStatusAll\n} TQ1InboxMessageStatus;\n\n\n\n\nAnd naturally, to get, let's say, unread pushes call \ngetInboxMessages\n  with a TQ1InboxMessageStatusUnread parameter:\n\n\n[[TQ1Inbox shared] getInboxMessages: TQ1InboxMessageStatusUnread]\n\n\n\n\nAnd if you need the read pushes use TQ1InboxMessageStatusRead as the parameter, and to get all use the TQ1InboxMessageStatusAll parameter.\n\n\nBut if it's only necessary to get how many pushes there are in the inbox, there is no necessity to get all the pushes and then count them. In this case simply call \ngetInboxMessagesCount\n. It's faster, it's better, it's cleaner. The method receives the same type of parameter as \ngetInboxMessages\n:\n\n\n[[TQ1Inbox shared] getInboxMessagesCount: TQ1InboxMessageStatusUnread]\n\n\n\n\nBe warned, though, that this returns an \"int\", not an \"NSInteger\" nor an \"NSNumber\".\n\n\nHandling a single push\n\n\nBy now the app should be able to list all pushes. Finally, to handle a single push.\nThere's just a few things to do with a single push.\nThe first of them is to mark a push as read or unread. So in the view controller, there should be some code as:\n\n\nif ([[TQ1Inbox shared] markAsRead:pushId]){\n  //The push was marked!\n}else{\n  //The push was not marked...\n}\n\n\n\n\nThe second is to delete the push. It deletes the push from the database:\n\n\nif ([[TQ1Inbox shared] removeMessage:pushId]){\n  //The push was deleted!\n}else{\n  //The push was not deleted...\n}\n\n\n\n\nAnd the third is to retrieve the pushes content. Since pushes and its' contents are not in the same table, it's necessary to retrieve it through the push:\n\n\n[[TQ1Inbox shared] retrieveCustomContent:pushId completion:^(BOOL success, TQ1InboxMessage *message)\n\n\n\n\nThe first parameter is the push's id and the second is a block that receives if it was possible to retrieve the content and the TQ1InboxMessage with the retrieved content.\n\n\nYou can also tell the SDK to download the content as soon as the notification arrives via the method call:\n\n\n[[TQ1Push shared] setDownloadAutomatic: true]\n\n\n\n\nKeep in mind that this is only possible when the application is currently running in background. When the user clicks on the notification, you can check whether the content was already downloaded or not by verifying the \ncomplete\n field. In the latter case the content should be requested:\n\n\nTQ1InboxMessage *notification;\nif(!notification.complete)\n{\n  // Request content HERE\n}\n\n\n\n\nRemoving Multiple Notifications\n\n\nThere is a method available for removing all notifications specified by its \nTQ1InboxMessageStatus\n: \nREAD\n, \nUNREAD\n or \nALL\n.\n\n\n[[TQ1Inbox shared] removeMessagesWithStatus: TQ1InboxMessageStatusAll]", 
            "title": "5 Notifications"
        }, 
        {
            "location": "/4-notifications/#handling-incoming-pushes", 
            "text": "Basically there are two classes that handle push notifications: TQ1Inbox and TQ1InboxMessage, both described in 'TQ1Inbox.h'.  Just note that, since there should only exist one TQ1Inbox per app, the correct way to call those methods is by sending the message to the 'shared' return. The 'shared' method will take care of creating an inbox or returning the existing one.  //For example:\n[[TQ1Inbox shared] getInboxMessage: @ 1234 ]  Also, one should create a class that handles how the app behaves when a push is received by implementing the TQDelegate protocol, defined in TQ1.h:  @protocol TQDelegate  NSObject \n  //method used to handle foreground push notifications\n  - (void)handleForegroundPushNotification:(NSDictionary *)userInfo pushId:(NSString *) pushId;\n\n  //method used to handle background push notifications\n  - (void)handleBackgroundPushNotification:(NSDictionary *)userInfo pushId:(NSString *) pushId;\n\n  //method to handle push notification custom actions\n  -(void)handleCustomActionWithIdentifier:(NSString *)identifier pushId:(NSString *)pushId\n@end  When the push first arrives, the app may or may not be open, in background, etc; so it's necessary to implement the protocol  TQDelegate  and the  didFinishLaunchingWithOptions  event that will determinate the actions to take in each state.\nIn special, the TQProtocol will describe what happens when the app is open, and in its' implementation it will become necessary to get the received push (to display it, for example). In that case one should use the method  getInboxMessage  inside the protocol's implementation, since they do receive the received push's id:  - (void)handleBackgroundPushNotification:(NSDictionary *)userInfo pushId:(NSString *) pushId\n{\n    TQ1InboxMessage *receivedPush;\n    //Code\n    receivedPush = [[[TQ1Inbox] shared] getInboxMessage: pushId];\n    //More code\n}", 
            "title": "Handling incoming pushes"
        }, 
        {
            "location": "/4-notifications/#getting-the-push-notification-custom-content", 
            "text": "When you send a custom content along with a push notification, you must first request this content to our server before using it. In order to do this you can use the  retrieveCustomContent  method, like in the following example:  -(void)handleBackgroundPushNotification:(NSDictionary *)userInfo pushId:(NSString *)pushId\n{\n    TQ1InboxMessage *message = [[TQ1Inbox shared] getInboxMessage:pushId];\n    if(!notification.complete)\n    {\n        [[TQ1Inbox shared] retrieveCustomContent:notification.id completion:^(BOOL success, TQ1InboxMessage *notification)\n        {\n            //handle notification content\n        }];\n    }\n    else\n    {\n        //handle notification content\n    }\n}  You can find more details about this method below.", 
            "title": "Getting the push notification custom content"
        }, 
        {
            "location": "/4-notifications/#handling-the-notification-content", 
            "text": "There are three types of notification content:   HTML - An HTML to be rendered by the app  Link - An URL, usually for showing a page in a web view  Tag - Key/value pair, usually for redirecting to pages inside the application   Note that the app is responsible for treating the content, so the possiblities are infinite. Here is an example on how to handle these contents:  // This is for the notifications whose types are custom content (html) and external link (link)\nif(notification.type == TQ1InboxMessageTypeHtml || notification.type == TQ1InboxMessageTypeLink)\n{\n    ContentViewController *ctrl = [[ContentViewController alloc] init];\n    ctrl.notification = notification;\n    ctrl.notification = [[TQ1Inbox shared] getInboxMessage:notification.id];\n    [navController pushViewController:ctrl animated:YES];\n}\n\n// This is for notifications whose type is app redirection (tag) - Goes to the view tag indicates\nelse if(notification.type == TQ1InboxMessageTypeTag)\n{\n    if([notification.content objectForKey:@ Search ])\n    {\n        SearchViewController *searchCtrl = [[SearchViewController alloc] init];\n        [navController pushViewController:searchCtrl animated:YES];\n    }\n    if(notification.status == TQ1InboxMessageStatusUnread)\n        [[TQ1Inbox shared] markAsRead:notification.id];\n}", 
            "title": "Handling the notification content"
        }, 
        {
            "location": "/4-notifications/#handling-all-received-pushes", 
            "text": "Now, when there are already received pushes in the inbox and it's necessary to show those, the natural thing to do should be to get all read/unread pushes, and to do that call  getInboxMessages  on the inbox. That method takes a status to do the filtering. The possible status are defined in an enum in the header, but here they are:  typedef enum\n{\n  TQ1InboxMessageStatusUnread,\n  TQ1InboxMessageStatusRead,\n  TQ1InboxMessageStatusAll\n} TQ1InboxMessageStatus;  And naturally, to get, let's say, unread pushes call  getInboxMessages   with a TQ1InboxMessageStatusUnread parameter:  [[TQ1Inbox shared] getInboxMessages: TQ1InboxMessageStatusUnread]  And if you need the read pushes use TQ1InboxMessageStatusRead as the parameter, and to get all use the TQ1InboxMessageStatusAll parameter.  But if it's only necessary to get how many pushes there are in the inbox, there is no necessity to get all the pushes and then count them. In this case simply call  getInboxMessagesCount . It's faster, it's better, it's cleaner. The method receives the same type of parameter as  getInboxMessages :  [[TQ1Inbox shared] getInboxMessagesCount: TQ1InboxMessageStatusUnread]  Be warned, though, that this returns an \"int\", not an \"NSInteger\" nor an \"NSNumber\".", 
            "title": "Handling all received pushes"
        }, 
        {
            "location": "/4-notifications/#handling-a-single-push", 
            "text": "By now the app should be able to list all pushes. Finally, to handle a single push.\nThere's just a few things to do with a single push.\nThe first of them is to mark a push as read or unread. So in the view controller, there should be some code as:  if ([[TQ1Inbox shared] markAsRead:pushId]){\n  //The push was marked!\n}else{\n  //The push was not marked...\n}  The second is to delete the push. It deletes the push from the database:  if ([[TQ1Inbox shared] removeMessage:pushId]){\n  //The push was deleted!\n}else{\n  //The push was not deleted...\n}  And the third is to retrieve the pushes content. Since pushes and its' contents are not in the same table, it's necessary to retrieve it through the push:  [[TQ1Inbox shared] retrieveCustomContent:pushId completion:^(BOOL success, TQ1InboxMessage *message)  The first parameter is the push's id and the second is a block that receives if it was possible to retrieve the content and the TQ1InboxMessage with the retrieved content.  You can also tell the SDK to download the content as soon as the notification arrives via the method call:  [[TQ1Push shared] setDownloadAutomatic: true]  Keep in mind that this is only possible when the application is currently running in background. When the user clicks on the notification, you can check whether the content was already downloaded or not by verifying the  complete  field. In the latter case the content should be requested:  TQ1InboxMessage *notification;\nif(!notification.complete)\n{\n  // Request content HERE\n}", 
            "title": "Handling a single push"
        }, 
        {
            "location": "/4-notifications/#removing-multiple-notifications", 
            "text": "There is a method available for removing all notifications specified by its  TQ1InboxMessageStatus :  READ ,  UNREAD  or  ALL .  [[TQ1Inbox shared] removeMessagesWithStatus: TQ1InboxMessageStatusAll]", 
            "title": "Removing Multiple Notifications"
        }, 
        {
            "location": "/5-Geonotifications/", 
            "text": "Working with TQ1 + TQG\n\n\nBefore going on, check \nTQG docs\n on how to add it and setup in your project.\n\n\nOnce TQG is all set, you will need to \"tell\" TQ1 that you are using TQG. The first thing to do is to implement \nTQGeotriggerDelegate\n and \nTQGeotrackerDelegate\n interfaces. Here is an example where TQG is being used in these classes:\n\n\n//TQGManager.h\n#import \nFoundation/Foundation.h\n\n#import \nUIKit/UILocalNotification.h\n\n#import \nUIKit/UIApplication.h\n\n#import \nTQ1Geotrigger.h\n\n#import \nTQGeolocationSDK-Swift.h\n\n\n@interface TQGManager: NSObject \nTQGeoTriggerDelegate, TQGeoTrackerDelegate\n\n\n@end\n\n\n\n\n//TQGManager.m\n#import \nTQGManager.h\n\n\n@implementation TQGManager\n\n- (void)configure:(void (^)(void))completion\n{\n    [[TQGeoTracker sharedInstance] configure:@TQGKey triggerMode:TriggerModes.Both environment:TQEnvironments.Production];\n    [[TQGeoTracker sharedInstance] setTriggerDelegate:self];\n    completion();\n}\n\n- (void)start\n{\n    [[TQGeoTracker sharedInstance] start];\n}\n\n- (void)stop\n{\n    [[TQGeoTracker sharedInstance] stop];\n}\n\n- (void)resume\n{\n    [[TQGeoTracker sharedInstance] start];\n}\n\n- (void)pause\n{\n    [[TQGeoTracker sharedInstance] stop];\n}\n\n- (NSString *)getDeviceId\n{\n    return [[TQGeoTracker sharedInstance] getDeviceId];\n}\n\n- (void)TQGeoTrackerOnFenceTriggered:(TQGeoTracker *)tqGeoTracker fenceName:(NSString *)fenceName fenceId:(NSString *)fenceId type:(NSString *)type\n{\n    [[TQGeoTracker sharedInstance] log:[NSString stringWithFormat:@\nOnFenceTriggered - fenceName: %@ fenceId: %@ type: %@\n, fenceName, fenceId, type]];\n\n    //Send local notification\n    UILocalNotification *notification = [[UILocalNotification alloc] init];\n    notification.fireDate = [[NSDate alloc] init];\n    notification.alertBody = [NSString stringWithFormat:@\nfenceName: %@ fenceId: %@ type: %@\n, fenceName, fenceId, type];\n    [[UIApplication sharedApplication] scheduleLocalNotification: notification];\n}\n\n@end\n\n\n\n\nWith these classes implemented, you can use its' methods to start TQG:\n\n\n[[TQ1Geotrigger shared] setManager:[[TQGManager alloc] init]];\n[[TQ1Geotrigger shared] startGeotriggerService];", 
            "title": "6 Geonotifications"
        }, 
        {
            "location": "/5-Geonotifications/#working-with-tq1-tqg", 
            "text": "Before going on, check  TQG docs  on how to add it and setup in your project.  Once TQG is all set, you will need to \"tell\" TQ1 that you are using TQG. The first thing to do is to implement  TQGeotriggerDelegate  and  TQGeotrackerDelegate  interfaces. Here is an example where TQG is being used in these classes:  //TQGManager.h\n#import  Foundation/Foundation.h \n#import  UIKit/UILocalNotification.h \n#import  UIKit/UIApplication.h \n#import  TQ1Geotrigger.h \n#import  TQGeolocationSDK-Swift.h \n\n@interface TQGManager: NSObject  TQGeoTriggerDelegate, TQGeoTrackerDelegate \n\n@end  //TQGManager.m\n#import  TQGManager.h \n\n@implementation TQGManager\n\n- (void)configure:(void (^)(void))completion\n{\n    [[TQGeoTracker sharedInstance] configure:@TQGKey triggerMode:TriggerModes.Both environment:TQEnvironments.Production];\n    [[TQGeoTracker sharedInstance] setTriggerDelegate:self];\n    completion();\n}\n\n- (void)start\n{\n    [[TQGeoTracker sharedInstance] start];\n}\n\n- (void)stop\n{\n    [[TQGeoTracker sharedInstance] stop];\n}\n\n- (void)resume\n{\n    [[TQGeoTracker sharedInstance] start];\n}\n\n- (void)pause\n{\n    [[TQGeoTracker sharedInstance] stop];\n}\n\n- (NSString *)getDeviceId\n{\n    return [[TQGeoTracker sharedInstance] getDeviceId];\n}\n\n- (void)TQGeoTrackerOnFenceTriggered:(TQGeoTracker *)tqGeoTracker fenceName:(NSString *)fenceName fenceId:(NSString *)fenceId type:(NSString *)type\n{\n    [[TQGeoTracker sharedInstance] log:[NSString stringWithFormat:@ OnFenceTriggered - fenceName: %@ fenceId: %@ type: %@ , fenceName, fenceId, type]];\n\n    //Send local notification\n    UILocalNotification *notification = [[UILocalNotification alloc] init];\n    notification.fireDate = [[NSDate alloc] init];\n    notification.alertBody = [NSString stringWithFormat:@ fenceName: %@ fenceId: %@ type: %@ , fenceName, fenceId, type];\n    [[UIApplication sharedApplication] scheduleLocalNotification: notification];\n}\n\n@end  With these classes implemented, you can use its' methods to start TQG:  [[TQ1Geotrigger shared] setManager:[[TQGManager alloc] init]];\n[[TQ1Geotrigger shared] startGeotriggerService];", 
            "title": "Working with TQ1 + TQG"
        }, 
        {
            "location": "/6-troubleshooting/", 
            "text": "Troubleshooting\n\n\nMy device is not receiving notifications!\n\n\n\n\nCheck if your device is properly registering for push notifications, if you don't have the right certificates and provisioning profiles, you may even be able to run, but won't be able to register for push notifications. You can check the logs to see if the app is sending \ndevice-token\n to the server.\n\n\nCheck if your app key is correct.\n\n\nCheck if you are properly connected to the internet and the requests to TQ1 are returning \n200\n or \n204\n.\n\n\nCheck if the push certificate is properly generated.\n\n\nConfirm that you are using the correct build environment.\n\n\n\n\nIf all these checks pass, you can contact support team via e-mail, or through the admin page.\n\n\nI'm receiving normal notifications, but not geonotifications.\n\n\n\n\nCheck if you have properly initiated TQG.\n\n\nCheck TQG docs to see if you missed something\n\n\n\n\nIf all these checks pass, you can contact TQG support team.", 
            "title": "5 Troubleshooting"
        }, 
        {
            "location": "/6-troubleshooting/#troubleshooting", 
            "text": "", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/6-troubleshooting/#my-device-is-not-receiving-notifications", 
            "text": "Check if your device is properly registering for push notifications, if you don't have the right certificates and provisioning profiles, you may even be able to run, but won't be able to register for push notifications. You can check the logs to see if the app is sending  device-token  to the server.  Check if your app key is correct.  Check if you are properly connected to the internet and the requests to TQ1 are returning  200  or  204 .  Check if the push certificate is properly generated.  Confirm that you are using the correct build environment.   If all these checks pass, you can contact support team via e-mail, or through the admin page.", 
            "title": "My device is not receiving notifications!"
        }, 
        {
            "location": "/6-troubleshooting/#im-receiving-normal-notifications-but-not-geonotifications", 
            "text": "Check if you have properly initiated TQG.  Check TQG docs to see if you missed something   If all these checks pass, you can contact TQG support team.", 
            "title": "I'm receiving normal notifications, but not geonotifications."
        }
    ]
}